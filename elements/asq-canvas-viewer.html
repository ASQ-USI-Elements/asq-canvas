<link rel="import" href="../../polymer/polymer.html">
<link rel="import" href="../../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../asq-base/asq-base.html">
<link rel="import" href="asq-canvas-behaviour.html">
<link rel="import" href="asq-canvas-style.html">

<!--
`asq-canvas-viewer` provides the presenter view of `asq-text-input-q-stats`.

Example:

    <asq-canvas-viewer for="leId">
    </asq-canvas-viewer>


@element asq-canvas-viewer
@demo demo/stats.html
@group ASQ Elements
@blurb Element provides a stats for `asq-text-input-q` elements.
@homepage http://github.com/ASQ-USI-Elements/asq-text-input-q
-->
<dom-module id="asq-canvas-viewer">

  <template>

    <style include="asq-canvas-style"></style>

    <canvas id="canvas"></canvas>

  </template>
</dom-module>

<script>
  (function() {

    Polymer({
      is: 'asq-canvas-viewer',
      behaviors: [ASQ.asqCanvasElementBehavior],

      properties: {
        lastDrawing: {
          type: Object,
          value: {},
        },

        eventBus: {
          type: Object,
          observer: "_eventBusChanged",
          notify: true
        },
      },

      _eventBusChanged: function (eventBus, old) {
        if(!eventBus) return;
        eventBus.on('asq-plugin', this._onAsqPlugin.bind(this));
      },

      _onAsqPlugin: function(evt){
        if(evt.type !== "asq-canvas") return;

        var d = evt.data;

        switch (d.command){
          case "drawOnCanvas":

            var currentSlide = document.querySelector('.present');

            // get the width and height of the viewer's current slide
            var vSlideWidth = currentSlide.getBoundingClientRect().width;
            var vSlideHeight = document.body.offsetHeight - currentSlide.getBoundingClientRect().top - (document.body.offsetHeight - currentSlide.getBoundingClientRect().bottom);

            // get the midpoint of the viewer's current slide
            var vSMPX = currentSlide.getBoundingClientRect().left + vSlideWidth/2;
            var vSMPY = currentSlide.getBoundingClientRect().top + vSlideHeight/2;

            var x1 = this._computeCoordinate(d.mouseX, d.pSlideWidth, vSlideWidth, d.pSMPX, vSMPX);
            var y1 = this._computeCoordinate(d.mouseY, d.pSlideHeight, vSlideHeight, d.pSMPY, vSMPY);
            var x2 = this._computeCoordinate(d.lastX, d.pSlideWidth, vSlideWidth, d.pSMPX, vSMPX);
            var y2 = this._computeCoordinate(d.lastY, d.pSlideHeight, vSlideHeight, d.pSMPY, vSMPY);

            // calculate the lineThickness for the viewer
            var lineThickness = d.lineThickness * (vSlideWidth * vSlideHeight)/(d.pSlideWidth * d.pSlideHeight)

            // set the drawing properties
            this.drawingColor = d.drawingColor;
            this.lineThickness = lineThickness;
            this.ctx.fillStyle = this.drawingColor;
            this.ctx.strokeStyle = this.drawingColor;
            if (d.form == "circle") {
              this._drawCircle(x1, y1, this.lineThickness);
            }
            else if (d.form == "line") {
              this._drawLine(x1, y1, x2, y2, this.lineThickness);
            }
            break;
          case "clearTo":
            this.clearTo();;
            break;

          case "loadImage":
            this.lastDrawing.drawing = d.dataURL;
            this._loadImage(this.lastDrawing.drawing);
            break;
        }
      },

      _computeCoordinate: function(pCoordinate, pSize, vSize, pMP, vMP) {
        return vMP + (pCoordinate - pMP) * (vSize/pSize);
      },

      _loadImage: function(data) {
        var img = new Image();
        if (data) {
          var context = this.ctx;
          img.addEventListener("load", function(evt) {
            setTimeout(function() {
              context.drawImage(img, 0, 0);
            }, 1000);
          });
          img.src = data;
        }
      },

    });
  })();
</script>

<script>
  var ASQ = window.ASQ || {};

  /**
   * This mixin object shares canvas functionalities.
   */
   var canvasElementBehaviour = ASQ.canvasElementBehaviour = {

    properties: {

      activeTool: {
        type: String,
        value: "pen",
      },

      drawingColor: {
        type: String,
        value: "#000000",
      },

      lineWidth: {
        type: Number,
        value: 6,
      },

    },

    attached: function() {
      this.ctx = this.$.canvas.getContext('2d');
      this.lastX = 0;
      this.lastY = 0;

      window.addEventListener('resize', this._resizeCanvas.bind(this), false);

      if (this.initialResize) {
        setTimeout(this._resizeCanvas, this.initialResize);
      }
      else {
        setTimeout(this._resizeCanvas.bind(this), 1000);
      }
    },

    _clearTo: function() {
      this.ctx.clearRect(0, 0, this.$.canvas.width, this.$.canvas.height);
    },

    _computeCoordinate: function(pCoordinate, pSize, vSize, pMP, vMP) {
      return vMP + (pCoordinate - pMP) * (vSize/pSize);
    },

    _drawLine: function(x1, y1, x2, y2, lineWidth) {
      this._drawOnCanvas("line", x1, y1, lineWidth, x2, y2);
    },

    _drawCircle: function(x, y, lineWidth) {
      this._drawOnCanvas("circle", x, y, lineWidth);
    },

    _drawOnCanvas: function(form, x1, y1, lineWidth, x2, y2) {
      var radius = lineWidth/2;

      for (var i = 0; i < lineWidth * lineWidth; ++i) {
        var currentX = i%lineWidth;
        var currentY = Math.floor(i/lineWidth);

        var canvasX1 = x1 - radius + currentX;
        var canvasY1 = y1 - radius + currentY;

        var canvasX2 = x2 - radius + currentX;
        var canvasY2 = y2 - radius + currentY;

        var hypotenuse = Math.sqrt(Math.pow(Math.abs(canvasX1 - x1), 2)
                       + Math.pow(Math.abs(canvasY1 - y1), 2));

        if ((radius >= 1)?  hypotenuse < radius : hypotenuse > radius) {
          switch (form) {
            case "circle":
              this.ctx.fillRect(canvasX1, canvasY1, 1, 1);
              break;

            case "line":
              this.ctx.beginPath();
              this.ctx.moveTo(canvasX1, canvasY1);
              this.ctx.lineTo(canvasX2, canvasY2);
              this.ctx.stroke();
              break;
          }
        }
      }
    },

    _loadImage: function(data, slideId) {
      if (slideId) var currentSlide = document.getElementById(slideId).getBoundingClientRect();
      else var currentSlide = document.querySelector('.present').getBoundingClientRect();

      // get the width and height of the viewer's current slide
      var cSlideWidth = currentSlide.width;
      var cSlideHeight = document.body.offsetHeight - currentSlide.top - (document.body.offsetHeight - currentSlide.bottom);

      // get the midpoint of the viewer's current slide
      var cSMX = currentSlide.left + cSlideWidth/2;
      var cSMY = currentSlide.top + cSlideHeight/2;

      data.forEach(function(drawStep) {
        var lineWidth = drawStep.lineWidth * (cSlideWidth * cSlideHeight)/(drawStep.pSlideWidth * drawStep.pSlideHeight);

        var x1 = this._computeCoordinate(drawStep.mouseX, drawStep.pSlideWidth, cSlideWidth, drawStep.pSMX, cSMX);
        var y1 = this._computeCoordinate(drawStep.mouseY, drawStep.pSlideHeight, cSlideHeight, drawStep.pSMY, cSMY);

        switch (drawStep.form) {
          case "circle":
            this.ctx.fillStyle = drawStep.drawingColor;
            this._drawCircle(x1, y1, lineWidth);
            break;

          case "line":
            var x2 = this._computeCoordinate(drawStep.lastX, drawStep.pSlideWidth, cSlideWidth, drawStep.pSMX, cSMX);
            var y2 = this._computeCoordinate(drawStep.lastY, drawStep.pSlideHeight, cSlideHeight, drawStep.pSMY, cSMY);

            this.ctx.strokeStyle = drawStep.drawingColor;
            this._drawLine(x1, y1, x2, y2, lineWidth);
            break;
        }

        this.lastX = drawStep.mouseX;
        this.lastY = drawStep.mouseY;
      }.bind(this));
    },

    _resizeCanvas: function () {
      var resizeAnimation = setInterval(function() {
        this._clearTo();
        this.$.canvas.width = this.offsetWidth;
        this.$.canvas.height = this.offsetHeight;

        if (this.role == 'viewer') {
          if (this.lastDrawing) this._loadImage(this.lastDrawing, this.currentSlide);
        }
        else {
          if (this.lastStep && this.drawings[this.lastStep]) this._loadImage(this.drawings[this.lastStep], this.lastStep);
        }
      }.bind(this), 1);

      setTimeout(function() {
        clearInterval(resizeAnimation);
      }, 3000);

    },

  };

  var asqCanvasElementBehavior = ASQ.asqElementBehavior.slice(0);
  asqCanvasElementBehavior.push(canvasElementBehaviour);
  ASQ.asqCanvasElementBehavior = [asqCanvasElementBehavior];
</script>
